/* 
 * @(#)Datastore.java        1.0
 *
 * This file has been auto-generated by JNC, the
 * Java output format plug-in of pyang.
 * Origin: module "tailf-confd-monitoring", revision: "2013-06-14".
 */

package com.airlenet.yang.model.tailfConfdMonitoring.confdState.internal.cdb;

import com.airlenet.yang.model.tailfCommonMonitoring.SizeInBytes;
import com.airlenet.yang.model.tailfCommonMonitoring.TfcgPrefix;
import com.airlenet.yang.model.tailfConfdMonitoring.confdState.internal.cdb.datastore.PendingNotificationQueue;
import com.airlenet.yang.model.tailfConfdMonitoring.confdState.internal.cdb.datastore.PendingSubscriptionSync;
import com.tailf.jnc.Element;
import com.tailf.jnc.ElementChildrenIterator;
import com.tailf.jnc.JNCException;
import com.tailf.jnc.NodeSet;
import com.tailf.jnc.YangBoolean;
import com.tailf.jnc.YangElement;
import com.tailf.jnc.YangEnumeration;
import com.tailf.jnc.YangString;
import com.tailf.jnc.YangUInt32;

import java.util.ArrayList;
import java.util.List;

/**
 * This class represents an element from 
 * the namespace http://tail-f.com/yang/confd-monitoring
 * generated to "src/main/java/com.airlenet.yang.model/tailfConfdMonitoring/confdState/internal/cdb/datastore"
 * <p>
 * See line 609 in
 * src/main/yang/module/tailf/tailf-common-monitoring.yang
 *
 * @version 1.0
 * @author Auto Generated
 */
public class Datastore extends YangElement {

    private static final long serialVersionUID = 1L;

    /**
     * Field for child container "pending-subscription-sync".
     */
    public PendingSubscriptionSync pendingSubscriptionSync = null;
    public PendingSubscriptionSync getPendingSubscriptionSync() {
        return this.pendingSubscriptionSync;
    }

    /**
     * Constructor for an empty Datastore object.
     */
    public Datastore() {
        super(TfcgPrefix.NAMESPACE, "datastore");
    }

    /**
     * Clones this object, returning an exact copy.
     * @return A clone of the object.
     */
    public Datastore clone() {
        return (Datastore)cloneContent(new Datastore());
    }

    /**
     * Clones this object, returning a shallow copy.
     * @return A clone of the object. Children are not included.
     */
    public Datastore cloneShallow() {
        return (Datastore)cloneShallowContent(new Datastore());
    }

    /**
     * @return An array with the identifiers of any key children
     */
    public String[] keyNames() {
        return null;
    }

    /**
     * @return An array with the identifiers of any children, in order.
     */
    public String[] childrenNames() {
        return new String[] {
            "name",
            "transaction-id",
            "write-queue",
            "filename",
            "disk-size",
            "ram-size",
            "read-locks",
            "write-lock-set",
            "subscription-lock-set",
            "waiting-for-replication-sync",
            "pending-subscription-sync",
            "pending-notification-queue",
        };
    }

    /* Access methods for leaf child: "name". */

    /**
     * Gets the value for child leaf "name".
     * @return The value of the leaf.
     */
    public com.tailf.jnc.YangEnumeration getNameValue() throws JNCException {
        return (com.tailf.jnc.YangEnumeration)getValue("name");
    }

    /**
     * Sets the value for child leaf "name",
     * using a JNC type value.
     * @param nameValue The value to set.
     * @param nameValue used during instantiation.
     */
    public void setNameValue(com.tailf.jnc.YangEnumeration nameValue)
            throws JNCException {
        setLeafValue(TfcgPrefix.NAMESPACE,
            "name",
            nameValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "name",
     * using a String value.
     * @param nameValue used during instantiation.
     */
    public void setNameValue(String nameValue) throws JNCException {
        setNameValue(new com.tailf.jnc.YangEnumeration(nameValue, new String[] {
        }));
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "name" leaf will not have a value.
     */
    public void addName() throws JNCException {
        setLeafValue(TfcgPrefix.NAMESPACE,
            "name",
            null,
            childrenNames());
    }

    /* Access methods for optional leaf child: "transaction-id". */

    /**
     * Gets the value for child leaf "transaction-id".
     * @return The value of the leaf.
     */
    public com.tailf.jnc.YangString getTransactionIdValue() throws JNCException {
        return (com.tailf.jnc.YangString)getValue("transaction-id");
    }

    /**
     * Sets the value for child leaf "transaction-id",
     * using instance of generated typedef class.
     * @param transactionIdValue The value to set.
     * @param transactionIdValue used during instantiation.
     */
    public void setTransactionIdValue(com.tailf.jnc.YangString transactionIdValue)
            throws JNCException {
        setLeafValue(TfcgPrefix.NAMESPACE,
            "transaction-id",
            transactionIdValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "transaction-id",
     * using a String value.
     * @param transactionIdValue used during instantiation.
     */
    public void setTransactionIdValue(String transactionIdValue)
            throws JNCException {
        setTransactionIdValue(new com.tailf.jnc.YangString(transactionIdValue));
    }

    /**
     * Unsets the value for child leaf "transaction-id".
     */
    public void unsetTransactionIdValue() throws JNCException {
        delete("transaction-id");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "transaction-id" leaf will not have a value.
     */
    public void addTransactionId() throws JNCException {
        setLeafValue(TfcgPrefix.NAMESPACE,
            "transaction-id",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "transaction-id" with operation "replace".
     */
    public void markTransactionIdReplace() throws JNCException {
        markLeafReplace("transaction-id");
    }

    /**
     * Marks the leaf "transaction-id" with operation "merge".
     */
    public void markTransactionIdMerge() throws JNCException {
        markLeafMerge("transaction-id");
    }

    /**
     * Marks the leaf "transaction-id" with operation "create".
     */
    public void markTransactionIdCreate() throws JNCException {
        markLeafCreate("transaction-id");
    }

    /**
     * Marks the leaf "transaction-id" with operation "delete".
     */
    public void markTransactionIdDelete() throws JNCException {
        markLeafDelete("transaction-id");
    }

    /**
     * Marks the leaf "transaction-id" with operation "remove".
     */
    public void markTransactionIdRemove() throws JNCException {
        markLeafRemove("transaction-id");
    }

    /* Access methods for optional leaf child: "write-queue". */

    /**
     * Gets the value for child leaf "write-queue".
     * @return The value of the leaf.
     */
    public com.tailf.jnc.YangUInt32 getWriteQueueValue() throws JNCException {
        return (com.tailf.jnc.YangUInt32)getValue("write-queue");
    }

    /**
     * Sets the value for child leaf "write-queue",
     * using instance of generated typedef class.
     * @param writeQueueValue The value to set.
     * @param writeQueueValue used during instantiation.
     */
    public void setWriteQueueValue(com.tailf.jnc.YangUInt32 writeQueueValue)
            throws JNCException {
        setLeafValue(TfcgPrefix.NAMESPACE,
            "write-queue",
            writeQueueValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "write-queue",
     * using Java primitive values.
     * @param writeQueueValue used during instantiation.
     */
    public void setWriteQueueValue(long writeQueueValue) throws JNCException {
        setWriteQueueValue(new com.tailf.jnc.YangUInt32(writeQueueValue));
    }

    /**
     * Sets the value for child leaf "write-queue",
     * using a String value.
     * @param writeQueueValue used during instantiation.
     */
    public void setWriteQueueValue(String writeQueueValue) throws JNCException {
        setWriteQueueValue(new com.tailf.jnc.YangUInt32(writeQueueValue));
    }

    /**
     * Unsets the value for child leaf "write-queue".
     */
    public void unsetWriteQueueValue() throws JNCException {
        delete("write-queue");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "write-queue" leaf will not have a value.
     */
    public void addWriteQueue() throws JNCException {
        setLeafValue(TfcgPrefix.NAMESPACE,
            "write-queue",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "write-queue" with operation "replace".
     */
    public void markWriteQueueReplace() throws JNCException {
        markLeafReplace("write-queue");
    }

    /**
     * Marks the leaf "write-queue" with operation "merge".
     */
    public void markWriteQueueMerge() throws JNCException {
        markLeafMerge("write-queue");
    }

    /**
     * Marks the leaf "write-queue" with operation "create".
     */
    public void markWriteQueueCreate() throws JNCException {
        markLeafCreate("write-queue");
    }

    /**
     * Marks the leaf "write-queue" with operation "delete".
     */
    public void markWriteQueueDelete() throws JNCException {
        markLeafDelete("write-queue");
    }

    /**
     * Marks the leaf "write-queue" with operation "remove".
     */
    public void markWriteQueueRemove() throws JNCException {
        markLeafRemove("write-queue");
    }

    /* Access methods for optional leaf child: "filename". */

    /**
     * Gets the value for child leaf "filename".
     * @return The value of the leaf.
     */
    public com.tailf.jnc.YangString getFilenameValue() throws JNCException {
        return (com.tailf.jnc.YangString)getValue("filename");
    }

    /**
     * Sets the value for child leaf "filename",
     * using instance of generated typedef class.
     * @param filenameValue The value to set.
     * @param filenameValue used during instantiation.
     */
    public void setFilenameValue(com.tailf.jnc.YangString filenameValue)
            throws JNCException {
        setLeafValue(TfcgPrefix.NAMESPACE,
            "filename",
            filenameValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "filename",
     * using a String value.
     * @param filenameValue used during instantiation.
     */
    public void setFilenameValue(String filenameValue) throws JNCException {
        setFilenameValue(new com.tailf.jnc.YangString(filenameValue));
    }

    /**
     * Unsets the value for child leaf "filename".
     */
    public void unsetFilenameValue() throws JNCException {
        delete("filename");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "filename" leaf will not have a value.
     */
    public void addFilename() throws JNCException {
        setLeafValue(TfcgPrefix.NAMESPACE,
            "filename",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "filename" with operation "replace".
     */
    public void markFilenameReplace() throws JNCException {
        markLeafReplace("filename");
    }

    /**
     * Marks the leaf "filename" with operation "merge".
     */
    public void markFilenameMerge() throws JNCException {
        markLeafMerge("filename");
    }

    /**
     * Marks the leaf "filename" with operation "create".
     */
    public void markFilenameCreate() throws JNCException {
        markLeafCreate("filename");
    }

    /**
     * Marks the leaf "filename" with operation "delete".
     */
    public void markFilenameDelete() throws JNCException {
        markLeafDelete("filename");
    }

    /**
     * Marks the leaf "filename" with operation "remove".
     */
    public void markFilenameRemove() throws JNCException {
        markLeafRemove("filename");
    }

    /* Access methods for optional leaf child: "disk-size". */

    /**
     * Gets the value for child leaf "disk-size".
     * @return The value of the leaf.
     */
    public com.airlenet.yang.model.tailfCommonMonitoring.SizeInBytes getDiskSizeValue()
            throws JNCException {
        return (com.airlenet.yang.model.tailfCommonMonitoring.SizeInBytes)getValue("disk-size");
    }

    /**
     * Sets the value for child leaf "disk-size",
     * using a JNC type value.
     * @param diskSizeValue The value to set.
     * @param diskSizeValue used during instantiation.
     */
    public void setDiskSizeValue(com.airlenet.yang.model.tailfCommonMonitoring.SizeInBytes diskSizeValue)
            throws JNCException {
        setLeafValue(TfcgPrefix.NAMESPACE,
            "disk-size",
            diskSizeValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "disk-size",
     * using Java primitive values.
     * @param diskSizeValue used during instantiation.
     */
    public void setDiskSizeValue(java.math.BigInteger diskSizeValue)
            throws JNCException {
        setDiskSizeValue(new com.airlenet.yang.model.tailfCommonMonitoring.SizeInBytes(diskSizeValue));
    }

    /**
     * Sets the value for child leaf "disk-size",
     * using a String value.
     * @param diskSizeValue used during instantiation.
     */
    public void setDiskSizeValue(String diskSizeValue) throws JNCException {
        setDiskSizeValue(new com.airlenet.yang.model.tailfCommonMonitoring.SizeInBytes(diskSizeValue));
    }

    /**
     * Unsets the value for child leaf "disk-size".
     */
    public void unsetDiskSizeValue() throws JNCException {
        delete("disk-size");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "disk-size" leaf will not have a value.
     */
    public void addDiskSize() throws JNCException {
        setLeafValue(TfcgPrefix.NAMESPACE,
            "disk-size",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "disk-size" with operation "replace".
     */
    public void markDiskSizeReplace() throws JNCException {
        markLeafReplace("disk-size");
    }

    /**
     * Marks the leaf "disk-size" with operation "merge".
     */
    public void markDiskSizeMerge() throws JNCException {
        markLeafMerge("disk-size");
    }

    /**
     * Marks the leaf "disk-size" with operation "create".
     */
    public void markDiskSizeCreate() throws JNCException {
        markLeafCreate("disk-size");
    }

    /**
     * Marks the leaf "disk-size" with operation "delete".
     */
    public void markDiskSizeDelete() throws JNCException {
        markLeafDelete("disk-size");
    }

    /**
     * Marks the leaf "disk-size" with operation "remove".
     */
    public void markDiskSizeRemove() throws JNCException {
        markLeafRemove("disk-size");
    }

    /* Access methods for optional leaf child: "ram-size". */

    /**
     * Gets the value for child leaf "ram-size".
     * @return The value of the leaf.
     */
    public com.airlenet.yang.model.tailfCommonMonitoring.SizeInBytes getRamSizeValue()
            throws JNCException {
        return (com.airlenet.yang.model.tailfCommonMonitoring.SizeInBytes)getValue("ram-size");
    }

    /**
     * Sets the value for child leaf "ram-size",
     * using a JNC type value.
     * @param ramSizeValue The value to set.
     * @param ramSizeValue used during instantiation.
     */
    public void setRamSizeValue(com.airlenet.yang.model.tailfCommonMonitoring.SizeInBytes ramSizeValue)
            throws JNCException {
        setLeafValue(TfcgPrefix.NAMESPACE,
            "ram-size",
            ramSizeValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "ram-size",
     * using Java primitive values.
     * @param ramSizeValue used during instantiation.
     */
    public void setRamSizeValue(java.math.BigInteger ramSizeValue)
            throws JNCException {
        setRamSizeValue(new com.airlenet.yang.model.tailfCommonMonitoring.SizeInBytes(ramSizeValue));
    }

    /**
     * Sets the value for child leaf "ram-size",
     * using a String value.
     * @param ramSizeValue used during instantiation.
     */
    public void setRamSizeValue(String ramSizeValue) throws JNCException {
        setRamSizeValue(new com.airlenet.yang.model.tailfCommonMonitoring.SizeInBytes(ramSizeValue));
    }

    /**
     * Unsets the value for child leaf "ram-size".
     */
    public void unsetRamSizeValue() throws JNCException {
        delete("ram-size");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "ram-size" leaf will not have a value.
     */
    public void addRamSize() throws JNCException {
        setLeafValue(TfcgPrefix.NAMESPACE,
            "ram-size",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "ram-size" with operation "replace".
     */
    public void markRamSizeReplace() throws JNCException {
        markLeafReplace("ram-size");
    }

    /**
     * Marks the leaf "ram-size" with operation "merge".
     */
    public void markRamSizeMerge() throws JNCException {
        markLeafMerge("ram-size");
    }

    /**
     * Marks the leaf "ram-size" with operation "create".
     */
    public void markRamSizeCreate() throws JNCException {
        markLeafCreate("ram-size");
    }

    /**
     * Marks the leaf "ram-size" with operation "delete".
     */
    public void markRamSizeDelete() throws JNCException {
        markLeafDelete("ram-size");
    }

    /**
     * Marks the leaf "ram-size" with operation "remove".
     */
    public void markRamSizeRemove() throws JNCException {
        markLeafRemove("ram-size");
    }

    /* Access methods for optional leaf child: "read-locks". */

    /**
     * Gets the value for child leaf "read-locks".
     * @return The value of the leaf.
     */
    public com.tailf.jnc.YangUInt32 getReadLocksValue() throws JNCException {
        return (com.tailf.jnc.YangUInt32)getValue("read-locks");
    }

    /**
     * Sets the value for child leaf "read-locks",
     * using instance of generated typedef class.
     * @param readLocksValue The value to set.
     * @param readLocksValue used during instantiation.
     */
    public void setReadLocksValue(com.tailf.jnc.YangUInt32 readLocksValue)
            throws JNCException {
        setLeafValue(TfcgPrefix.NAMESPACE,
            "read-locks",
            readLocksValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "read-locks",
     * using Java primitive values.
     * @param readLocksValue used during instantiation.
     */
    public void setReadLocksValue(long readLocksValue) throws JNCException {
        setReadLocksValue(new com.tailf.jnc.YangUInt32(readLocksValue));
    }

    /**
     * Sets the value for child leaf "read-locks",
     * using a String value.
     * @param readLocksValue used during instantiation.
     */
    public void setReadLocksValue(String readLocksValue) throws JNCException {
        setReadLocksValue(new com.tailf.jnc.YangUInt32(readLocksValue));
    }

    /**
     * Unsets the value for child leaf "read-locks".
     */
    public void unsetReadLocksValue() throws JNCException {
        delete("read-locks");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "read-locks" leaf will not have a value.
     */
    public void addReadLocks() throws JNCException {
        setLeafValue(TfcgPrefix.NAMESPACE,
            "read-locks",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "read-locks" with operation "replace".
     */
    public void markReadLocksReplace() throws JNCException {
        markLeafReplace("read-locks");
    }

    /**
     * Marks the leaf "read-locks" with operation "merge".
     */
    public void markReadLocksMerge() throws JNCException {
        markLeafMerge("read-locks");
    }

    /**
     * Marks the leaf "read-locks" with operation "create".
     */
    public void markReadLocksCreate() throws JNCException {
        markLeafCreate("read-locks");
    }

    /**
     * Marks the leaf "read-locks" with operation "delete".
     */
    public void markReadLocksDelete() throws JNCException {
        markLeafDelete("read-locks");
    }

    /**
     * Marks the leaf "read-locks" with operation "remove".
     */
    public void markReadLocksRemove() throws JNCException {
        markLeafRemove("read-locks");
    }

    /* Access methods for optional leaf child: "write-lock-set". */

    /**
     * Gets the value for child leaf "write-lock-set".
     * @return The value of the leaf.
     */
    public com.tailf.jnc.YangBoolean getWriteLockSetValue() throws JNCException {
        return (com.tailf.jnc.YangBoolean)getValue("write-lock-set");
    }

    /**
     * Sets the value for child leaf "write-lock-set",
     * using instance of generated typedef class.
     * @param writeLockSetValue The value to set.
     * @param writeLockSetValue used during instantiation.
     */
    public void setWriteLockSetValue(com.tailf.jnc.YangBoolean writeLockSetValue)
            throws JNCException {
        setLeafValue(TfcgPrefix.NAMESPACE,
            "write-lock-set",
            writeLockSetValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "write-lock-set",
     * using Java primitive values.
     * @param writeLockSetValue used during instantiation.
     */
    public void setWriteLockSetValue(Boolean writeLockSetValue)
            throws JNCException {
        setWriteLockSetValue(new com.tailf.jnc.YangBoolean(writeLockSetValue));
    }

    /**
     * Sets the value for child leaf "write-lock-set",
     * using a String value.
     * @param writeLockSetValue used during instantiation.
     */
    public void setWriteLockSetValue(String writeLockSetValue)
            throws JNCException {
        setWriteLockSetValue(new com.tailf.jnc.YangBoolean(writeLockSetValue));
    }

    /**
     * Unsets the value for child leaf "write-lock-set".
     */
    public void unsetWriteLockSetValue() throws JNCException {
        delete("write-lock-set");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "write-lock-set" leaf will not have a value.
     */
    public void addWriteLockSet() throws JNCException {
        setLeafValue(TfcgPrefix.NAMESPACE,
            "write-lock-set",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "write-lock-set" with operation "replace".
     */
    public void markWriteLockSetReplace() throws JNCException {
        markLeafReplace("write-lock-set");
    }

    /**
     * Marks the leaf "write-lock-set" with operation "merge".
     */
    public void markWriteLockSetMerge() throws JNCException {
        markLeafMerge("write-lock-set");
    }

    /**
     * Marks the leaf "write-lock-set" with operation "create".
     */
    public void markWriteLockSetCreate() throws JNCException {
        markLeafCreate("write-lock-set");
    }

    /**
     * Marks the leaf "write-lock-set" with operation "delete".
     */
    public void markWriteLockSetDelete() throws JNCException {
        markLeafDelete("write-lock-set");
    }

    /**
     * Marks the leaf "write-lock-set" with operation "remove".
     */
    public void markWriteLockSetRemove() throws JNCException {
        markLeafRemove("write-lock-set");
    }

    /* Access methods for optional leaf child: "subscription-lock-set". */

    /**
     * Gets the value for child leaf "subscription-lock-set".
     * @return The value of the leaf.
     */
    public com.tailf.jnc.YangBoolean getSubscriptionLockSetValue()
            throws JNCException {
        return (com.tailf.jnc.YangBoolean)getValue("subscription-lock-set");
    }

    /**
     * Sets the value for child leaf "subscription-lock-set",
     * using instance of generated typedef class.
     * @param subscriptionLockSetValue The value to set.
     * @param subscriptionLockSetValue used during instantiation.
     */
    public void setSubscriptionLockSetValue(com.tailf.jnc.YangBoolean subscriptionLockSetValue)
            throws JNCException {
        setLeafValue(TfcgPrefix.NAMESPACE,
            "subscription-lock-set",
            subscriptionLockSetValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "subscription-lock-set",
     * using Java primitive values.
     * @param subscriptionLockSetValue used during instantiation.
     */
    public void setSubscriptionLockSetValue(Boolean subscriptionLockSetValue)
            throws JNCException {
        setSubscriptionLockSetValue(new com.tailf.jnc.YangBoolean(subscriptionLockSetValue));
    }

    /**
     * Sets the value for child leaf "subscription-lock-set",
     * using a String value.
     * @param subscriptionLockSetValue used during instantiation.
     */
    public void setSubscriptionLockSetValue(String subscriptionLockSetValue)
            throws JNCException {
        setSubscriptionLockSetValue(new com.tailf.jnc.YangBoolean(subscriptionLockSetValue));
    }

    /**
     * Unsets the value for child leaf "subscription-lock-set".
     */
    public void unsetSubscriptionLockSetValue() throws JNCException {
        delete("subscription-lock-set");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "subscription-lock-set" leaf will not have a value.
     */
    public void addSubscriptionLockSet() throws JNCException {
        setLeafValue(TfcgPrefix.NAMESPACE,
            "subscription-lock-set",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "subscription-lock-set" with operation "replace".
     */
    public void markSubscriptionLockSetReplace() throws JNCException {
        markLeafReplace("subscription-lock-set");
    }

    /**
     * Marks the leaf "subscription-lock-set" with operation "merge".
     */
    public void markSubscriptionLockSetMerge() throws JNCException {
        markLeafMerge("subscription-lock-set");
    }

    /**
     * Marks the leaf "subscription-lock-set" with operation "create".
     */
    public void markSubscriptionLockSetCreate() throws JNCException {
        markLeafCreate("subscription-lock-set");
    }

    /**
     * Marks the leaf "subscription-lock-set" with operation "delete".
     */
    public void markSubscriptionLockSetDelete() throws JNCException {
        markLeafDelete("subscription-lock-set");
    }

    /**
     * Marks the leaf "subscription-lock-set" with operation "remove".
     */
    public void markSubscriptionLockSetRemove() throws JNCException {
        markLeafRemove("subscription-lock-set");
    }

    /* Access methods for optional leaf child: "waiting-for-replication-sync". */

    /**
     * Gets the value for child leaf "waiting-for-replication-sync".
     * @return The value of the leaf.
     */
    public com.tailf.jnc.YangBoolean getWaitingForReplicationSyncValue()
            throws JNCException {
        return (com.tailf.jnc.YangBoolean)getValue("waiting-for-replication-sync");
    }

    /**
     * Sets the value for child leaf "waiting-for-replication-sync",
     * using instance of generated typedef class.
     * @param waitingForReplicationSyncValue The value to set.
     * @param waitingForReplicationSyncValue used during instantiation.
     */
    public void setWaitingForReplicationSyncValue(com.tailf.jnc.YangBoolean waitingForReplicationSyncValue)
            throws JNCException {
        setLeafValue(TfcgPrefix.NAMESPACE,
            "waiting-for-replication-sync",
            waitingForReplicationSyncValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "waiting-for-replication-sync",
     * using Java primitive values.
     * @param waitingForReplicationSyncValue used during instantiation.
     */
    public void setWaitingForReplicationSyncValue(Boolean waitingForReplicationSyncValue)
            throws JNCException {
        setWaitingForReplicationSyncValue(new com.tailf.jnc.YangBoolean(waitingForReplicationSyncValue));
    }

    /**
     * Sets the value for child leaf "waiting-for-replication-sync",
     * using a String value.
     * @param waitingForReplicationSyncValue used during instantiation.
     */
    public void setWaitingForReplicationSyncValue(String waitingForReplicationSyncValue)
            throws JNCException {
        setWaitingForReplicationSyncValue(new com.tailf.jnc.YangBoolean(waitingForReplicationSyncValue));
    }

    /**
     * Unsets the value for child leaf "waiting-for-replication-sync".
     */
    public void unsetWaitingForReplicationSyncValue() throws JNCException {
        delete("waiting-for-replication-sync");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "waiting-for-replication-sync" leaf will not have a value.
     */
    public void addWaitingForReplicationSync() throws JNCException {
        setLeafValue(TfcgPrefix.NAMESPACE,
            "waiting-for-replication-sync",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "waiting-for-replication-sync" with operation "replace".
     */
    public void markWaitingForReplicationSyncReplace() throws JNCException {
        markLeafReplace("waiting-for-replication-sync");
    }

    /**
     * Marks the leaf "waiting-for-replication-sync" with operation "merge".
     */
    public void markWaitingForReplicationSyncMerge() throws JNCException {
        markLeafMerge("waiting-for-replication-sync");
    }

    /**
     * Marks the leaf "waiting-for-replication-sync" with operation "create".
     */
    public void markWaitingForReplicationSyncCreate() throws JNCException {
        markLeafCreate("waiting-for-replication-sync");
    }

    /**
     * Marks the leaf "waiting-for-replication-sync" with operation "delete".
     */
    public void markWaitingForReplicationSyncDelete() throws JNCException {
        markLeafDelete("waiting-for-replication-sync");
    }

    /**
     * Marks the leaf "waiting-for-replication-sync" with operation "remove".
     */
    public void markWaitingForReplicationSyncRemove() throws JNCException {
        markLeafRemove("waiting-for-replication-sync");
    }

    /* Access methods for container child: "pending-subscription-sync". */

    /**
     * Adds container entry "pendingSubscriptionSync", using an existing object.
     * @param pendingSubscriptionSync The object to add.
     * @return The added child.
     */
    public PendingSubscriptionSync addPendingSubscriptionSync(PendingSubscriptionSync pendingSubscriptionSync)
            throws JNCException {
        this.pendingSubscriptionSync = pendingSubscriptionSync;
        insertChild(pendingSubscriptionSync, childrenNames());
        return pendingSubscriptionSync;
    }

    /**
     * Adds container entry "pendingSubscriptionSync".
     * This method is used for creating subtree filters.
     * @return The added child.
     */
    public PendingSubscriptionSync addPendingSubscriptionSync()
            throws JNCException {
        PendingSubscriptionSync pendingSubscriptionSync = new PendingSubscriptionSync();
        this.pendingSubscriptionSync = pendingSubscriptionSync;
        insertChild(pendingSubscriptionSync, childrenNames());
        return pendingSubscriptionSync;
    }

    /**
     * Deletes container entry "pendingSubscriptionSync".
     * @return An array of the deleted element nodes.
     */
    public NodeSet deletePendingSubscriptionSync() throws JNCException {
        this.pendingSubscriptionSync = null;
        String path = "pending-subscription-sync";
        return delete(path);
    }

    /* Access methods for list child: "pending-notification-queue". */

    /**
     * Gets list entry "pendingNotificationQueue", with specified keys.
     */
    public PendingNotificationQueue getPendingNotificationQueue()
            throws JNCException {
        String path = "pending-notification-queue";
        return (PendingNotificationQueue)searchOne(path);
    }

    /**
     * Iterator method for the list "pending-notification-queue".
     * @return An iterator for the list.
     */
    public ElementChildrenIterator pendingNotificationQueueIterator() {
        return new ElementChildrenIterator(children, "pending-notification-queue");
    }

    /**
     * List method for the list "pending-notification-queue".
     * @return An List for the list.
     */
    public List<PendingNotificationQueue> getPendingNotificationQueueList() {
        List<PendingNotificationQueue> list = new ArrayList<>();
        ElementChildrenIterator iterator = pendingNotificationQueueIterator();
        if(iterator==null){
            return null;
        }
        while (iterator.hasNext()){
            PendingNotificationQueue next =(PendingNotificationQueue) iterator.next();
            list.add(next);
        }
        return list;
    }

    /**
     * Adds list entry "pendingNotificationQueue", using an existing object.
     * @param pendingNotificationQueue The object to add.
     * @return The added child.
     */
    public PendingNotificationQueue addPendingNotificationQueue(PendingNotificationQueue pendingNotificationQueue)
            throws JNCException {
        insertChild(pendingNotificationQueue, childrenNames());
        return pendingNotificationQueue;
    }

    /**
     * Adds list entry "pendingNotificationQueue".
     * This method is used for creating subtree filters.
     * @return The added child.
     */
    public PendingNotificationQueue addPendingNotificationQueue()
            throws JNCException {
        PendingNotificationQueue pendingNotificationQueue = new PendingNotificationQueue();
        insertChild(pendingNotificationQueue, childrenNames());
        return pendingNotificationQueue;
    }

    /**
     * Deletes list entry "pendingNotificationQueue", with specified keys.
     */
    public void deletePendingNotificationQueue() throws JNCException {
        String path = "pending-notification-queue";
        delete(path);
    }

    /**
     * Support method for addChild.
     * Adds a child to this object.
     * 
     * @param child The child to add
     */
    public void addChild(Element child) {
        super.addChild(child);
        if (child instanceof PendingSubscriptionSync) pendingSubscriptionSync = (PendingSubscriptionSync)child;
    }

}
