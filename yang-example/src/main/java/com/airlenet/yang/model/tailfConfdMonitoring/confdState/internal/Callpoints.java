/* 
 * @(#)Callpoints.java        1.0
 *
 * This file has been auto-generated by JNC, the
 * Java output format plug-in of pyang.
 * Origin: module "tailf-confd-monitoring", revision: "2013-06-14".
 */

package com.airlenet.yang.model.tailfConfdMonitoring.confdState.internal;

import com.airlenet.yang.model.tailfCommonMonitoring.TfcgPrefix;
import com.airlenet.yang.model.tailfConfdMonitoring.confdState.internal.callpoints.Actionpoint;
import com.airlenet.yang.model.tailfConfdMonitoring.confdState.internal.callpoints.AuthenticationCallback;
import com.airlenet.yang.model.tailfConfdMonitoring.confdState.internal.callpoints.AuthorizationCallbacks;
import com.airlenet.yang.model.tailfConfdMonitoring.confdState.internal.callpoints.Callpoint;
import com.airlenet.yang.model.tailfConfdMonitoring.confdState.internal.callpoints.ErrorFormattingCallback;
import com.airlenet.yang.model.tailfConfdMonitoring.confdState.internal.callpoints.NotificationStreamReplay;
import com.airlenet.yang.model.tailfConfdMonitoring.confdState.internal.callpoints.SnmpInformCallback;
import com.airlenet.yang.model.tailfConfdMonitoring.confdState.internal.callpoints.SnmpNotificationSubscription;
import com.airlenet.yang.model.tailfConfdMonitoring.confdState.internal.callpoints.Typepoint;
import com.airlenet.yang.model.tailfConfdMonitoring.confdState.internal.callpoints.Validationpoint;
import com.tailf.jnc.Element;
import com.tailf.jnc.ElementChildrenIterator;
import com.tailf.jnc.JNCException;
import com.tailf.jnc.NodeSet;
import com.tailf.jnc.YangElement;

import java.util.ArrayList;
import java.util.List;

/**
 * This class represents an element from 
 * the namespace http://tail-f.com/yang/confd-monitoring
 * generated to "src/main/java/com.airlenet.yang.model/tailfConfdMonitoring/confdState/internal/callpoints"
 * <p>
 * See line 509 in
 * src/main/yang/module/tailf/tailf-common-monitoring.yang
 *
 * @version 1.0
 * @author Auto Generated
 */
public class Callpoints extends YangElement {

    private static final long serialVersionUID = 1L;

    /**
     * Field for child container "authentication-callback".
     */
    public AuthenticationCallback authenticationCallback = null;
    public AuthenticationCallback getAuthenticationCallback() {
        return this.authenticationCallback;
    }

    /**
     * Field for child container "authorization-callbacks".
     */
    public AuthorizationCallbacks authorizationCallbacks = null;
    public AuthorizationCallbacks getAuthorizationCallbacks() {
        return this.authorizationCallbacks;
    }

    /**
     * Constructor for an empty Callpoints object.
     */
    public Callpoints() {
        super(TfcgPrefix.NAMESPACE, "callpoints");
    }

    /**
     * Clones this object, returning an exact copy.
     * @return A clone of the object.
     */
    public Callpoints clone() {
        return (Callpoints)cloneContent(new Callpoints());
    }

    /**
     * Clones this object, returning a shallow copy.
     * @return A clone of the object. Children are not included.
     */
    public Callpoints cloneShallow() {
        return (Callpoints)cloneShallowContent(new Callpoints());
    }

    /**
     * @return An array with the identifiers of any key children
     */
    public String[] keyNames() {
        return null;
    }

    /**
     * @return An array with the identifiers of any children, in order.
     */
    public String[] childrenNames() {
        return new String[] {
            "callpoint",
            "validationpoint",
            "actionpoint",
            "snmp-inform-callback",
            "snmp-notification-subscription",
            "error-formatting-callback",
            "typepoint",
            "notification-stream-replay",
            "authentication-callback",
            "authorization-callbacks",
        };
    }

    /* Access methods for list child: "callpoint". */

    /**
     * Gets list entry "callpoint", with specified keys.
     */
    public Callpoint getCallpoint() throws JNCException {
        String path = "callpoint";
        return (Callpoint)searchOne(path);
    }

    /**
     * Iterator method for the list "callpoint".
     * @return An iterator for the list.
     */
    public ElementChildrenIterator callpointIterator() {
        return new ElementChildrenIterator(children, "callpoint");
    }

    /**
     * List method for the list "callpoint".
     * @return An List for the list.
     */
    public List<Callpoint> getCallpointList() {
        List<Callpoint> list = new ArrayList<>();
        ElementChildrenIterator iterator = callpointIterator();
        if(iterator==null){
            return null;
        }
        while (iterator.hasNext()){
            Callpoint next =(Callpoint) iterator.next();
            list.add(next);
        }
        return list;
    }

    /**
     * Adds list entry "callpoint", using an existing object.
     * @param callpoint The object to add.
     * @return The added child.
     */
    public Callpoint addCallpoint(Callpoint callpoint) throws JNCException {
        insertChild(callpoint, childrenNames());
        return callpoint;
    }

    /**
     * Adds list entry "callpoint".
     * This method is used for creating subtree filters.
     * @return The added child.
     */
    public Callpoint addCallpoint() throws JNCException {
        Callpoint callpoint = new Callpoint();
        insertChild(callpoint, childrenNames());
        return callpoint;
    }

    /**
     * Deletes list entry "callpoint", with specified keys.
     */
    public void deleteCallpoint() throws JNCException {
        String path = "callpoint";
        delete(path);
    }

    /* Access methods for list child: "validationpoint". */

    /**
     * Gets list entry "validationpoint", with specified keys.
     */
    public Validationpoint getValidationpoint() throws JNCException {
        String path = "validationpoint";
        return (Validationpoint)searchOne(path);
    }

    /**
     * Iterator method for the list "validationpoint".
     * @return An iterator for the list.
     */
    public ElementChildrenIterator validationpointIterator() {
        return new ElementChildrenIterator(children, "validationpoint");
    }

    /**
     * List method for the list "validationpoint".
     * @return An List for the list.
     */
    public List<Validationpoint> getValidationpointList() {
        List<Validationpoint> list = new ArrayList<>();
        ElementChildrenIterator iterator = validationpointIterator();
        if(iterator==null){
            return null;
        }
        while (iterator.hasNext()){
            Validationpoint next =(Validationpoint) iterator.next();
            list.add(next);
        }
        return list;
    }

    /**
     * Adds list entry "validationpoint", using an existing object.
     * @param validationpoint The object to add.
     * @return The added child.
     */
    public Validationpoint addValidationpoint(Validationpoint validationpoint)
            throws JNCException {
        insertChild(validationpoint, childrenNames());
        return validationpoint;
    }

    /**
     * Adds list entry "validationpoint".
     * This method is used for creating subtree filters.
     * @return The added child.
     */
    public Validationpoint addValidationpoint() throws JNCException {
        Validationpoint validationpoint = new Validationpoint();
        insertChild(validationpoint, childrenNames());
        return validationpoint;
    }

    /**
     * Deletes list entry "validationpoint", with specified keys.
     */
    public void deleteValidationpoint() throws JNCException {
        String path = "validationpoint";
        delete(path);
    }

    /* Access methods for list child: "actionpoint". */

    /**
     * Gets list entry "actionpoint", with specified keys.
     */
    public Actionpoint getActionpoint() throws JNCException {
        String path = "actionpoint";
        return (Actionpoint)searchOne(path);
    }

    /**
     * Iterator method for the list "actionpoint".
     * @return An iterator for the list.
     */
    public ElementChildrenIterator actionpointIterator() {
        return new ElementChildrenIterator(children, "actionpoint");
    }

    /**
     * List method for the list "actionpoint".
     * @return An List for the list.
     */
    public List<Actionpoint> getActionpointList() {
        List<Actionpoint> list = new ArrayList<>();
        ElementChildrenIterator iterator = actionpointIterator();
        if(iterator==null){
            return null;
        }
        while (iterator.hasNext()){
            Actionpoint next =(Actionpoint) iterator.next();
            list.add(next);
        }
        return list;
    }

    /**
     * Adds list entry "actionpoint", using an existing object.
     * @param actionpoint The object to add.
     * @return The added child.
     */
    public Actionpoint addActionpoint(Actionpoint actionpoint)
            throws JNCException {
        insertChild(actionpoint, childrenNames());
        return actionpoint;
    }

    /**
     * Adds list entry "actionpoint".
     * This method is used for creating subtree filters.
     * @return The added child.
     */
    public Actionpoint addActionpoint() throws JNCException {
        Actionpoint actionpoint = new Actionpoint();
        insertChild(actionpoint, childrenNames());
        return actionpoint;
    }

    /**
     * Deletes list entry "actionpoint", with specified keys.
     */
    public void deleteActionpoint() throws JNCException {
        String path = "actionpoint";
        delete(path);
    }

    /* Access methods for list child: "snmp-inform-callback". */

    /**
     * Gets list entry "snmpInformCallback", with specified keys.
     */
    public SnmpInformCallback getSnmpInformCallback() throws JNCException {
        String path = "snmp-inform-callback";
        return (SnmpInformCallback)searchOne(path);
    }

    /**
     * Iterator method for the list "snmp-inform-callback".
     * @return An iterator for the list.
     */
    public ElementChildrenIterator snmpInformCallbackIterator() {
        return new ElementChildrenIterator(children, "snmp-inform-callback");
    }

    /**
     * List method for the list "snmp-inform-callback".
     * @return An List for the list.
     */
    public List<SnmpInformCallback> getSnmpInformCallbackList() {
        List<SnmpInformCallback> list = new ArrayList<>();
        ElementChildrenIterator iterator = snmpInformCallbackIterator();
        if(iterator==null){
            return null;
        }
        while (iterator.hasNext()){
            SnmpInformCallback next =(SnmpInformCallback) iterator.next();
            list.add(next);
        }
        return list;
    }

    /**
     * Adds list entry "snmpInformCallback", using an existing object.
     * @param snmpInformCallback The object to add.
     * @return The added child.
     */
    public SnmpInformCallback addSnmpInformCallback(SnmpInformCallback snmpInformCallback)
            throws JNCException {
        insertChild(snmpInformCallback, childrenNames());
        return snmpInformCallback;
    }

    /**
     * Adds list entry "snmpInformCallback".
     * This method is used for creating subtree filters.
     * @return The added child.
     */
    public SnmpInformCallback addSnmpInformCallback() throws JNCException {
        SnmpInformCallback snmpInformCallback = new SnmpInformCallback();
        insertChild(snmpInformCallback, childrenNames());
        return snmpInformCallback;
    }

    /**
     * Deletes list entry "snmpInformCallback", with specified keys.
     */
    public void deleteSnmpInformCallback() throws JNCException {
        String path = "snmp-inform-callback";
        delete(path);
    }

    /* Access methods for list child: "snmp-notification-subscription". */

    /**
     * Gets list entry "snmpNotificationSubscription", with specified keys.
     */
    public SnmpNotificationSubscription getSnmpNotificationSubscription()
            throws JNCException {
        String path = "snmp-notification-subscription";
        return (SnmpNotificationSubscription)searchOne(path);
    }

    /**
     * Iterator method for the list "snmp-notification-subscription".
     * @return An iterator for the list.
     */
    public ElementChildrenIterator snmpNotificationSubscriptionIterator() {
        return new ElementChildrenIterator(children, "snmp-notification-subscription");
    }

    /**
     * List method for the list "snmp-notification-subscription".
     * @return An List for the list.
     */
    public List<SnmpNotificationSubscription> getSnmpNotificationSubscriptionList() {
        List<SnmpNotificationSubscription> list = new ArrayList<>();
        ElementChildrenIterator iterator = snmpNotificationSubscriptionIterator();
        if(iterator==null){
            return null;
        }
        while (iterator.hasNext()){
            SnmpNotificationSubscription next =(SnmpNotificationSubscription) iterator.next();
            list.add(next);
        }
        return list;
    }

    /**
     * Adds list entry "snmpNotificationSubscription", using an existing object.
     * @param snmpNotificationSubscription The object to add.
     * @return The added child.
     */
    public SnmpNotificationSubscription addSnmpNotificationSubscription(SnmpNotificationSubscription snmpNotificationSubscription)
            throws JNCException {
        insertChild(snmpNotificationSubscription, childrenNames());
        return snmpNotificationSubscription;
    }

    /**
     * Adds list entry "snmpNotificationSubscription".
     * This method is used for creating subtree filters.
     * @return The added child.
     */
    public SnmpNotificationSubscription addSnmpNotificationSubscription()
            throws JNCException {
        SnmpNotificationSubscription snmpNotificationSubscription = new SnmpNotificationSubscription();
        insertChild(snmpNotificationSubscription, childrenNames());
        return snmpNotificationSubscription;
    }

    /**
     * Deletes list entry "snmpNotificationSubscription", with specified keys.
     */
    public void deleteSnmpNotificationSubscription() throws JNCException {
        String path = "snmp-notification-subscription";
        delete(path);
    }

    /* Access methods for list child: "error-formatting-callback". */

    /**
     * Gets list entry "errorFormattingCallback", with specified keys.
     */
    public ErrorFormattingCallback getErrorFormattingCallback()
            throws JNCException {
        String path = "error-formatting-callback";
        return (ErrorFormattingCallback)searchOne(path);
    }

    /**
     * Iterator method for the list "error-formatting-callback".
     * @return An iterator for the list.
     */
    public ElementChildrenIterator errorFormattingCallbackIterator() {
        return new ElementChildrenIterator(children, "error-formatting-callback");
    }

    /**
     * List method for the list "error-formatting-callback".
     * @return An List for the list.
     */
    public List<ErrorFormattingCallback> getErrorFormattingCallbackList() {
        List<ErrorFormattingCallback> list = new ArrayList<>();
        ElementChildrenIterator iterator = errorFormattingCallbackIterator();
        if(iterator==null){
            return null;
        }
        while (iterator.hasNext()){
            ErrorFormattingCallback next =(ErrorFormattingCallback) iterator.next();
            list.add(next);
        }
        return list;
    }

    /**
     * Adds list entry "errorFormattingCallback", using an existing object.
     * @param errorFormattingCallback The object to add.
     * @return The added child.
     */
    public ErrorFormattingCallback addErrorFormattingCallback(ErrorFormattingCallback errorFormattingCallback)
            throws JNCException {
        insertChild(errorFormattingCallback, childrenNames());
        return errorFormattingCallback;
    }

    /**
     * Adds list entry "errorFormattingCallback".
     * This method is used for creating subtree filters.
     * @return The added child.
     */
    public ErrorFormattingCallback addErrorFormattingCallback()
            throws JNCException {
        ErrorFormattingCallback errorFormattingCallback = new ErrorFormattingCallback();
        insertChild(errorFormattingCallback, childrenNames());
        return errorFormattingCallback;
    }

    /**
     * Deletes list entry "errorFormattingCallback", with specified keys.
     */
    public void deleteErrorFormattingCallback() throws JNCException {
        String path = "error-formatting-callback";
        delete(path);
    }

    /* Access methods for list child: "typepoint". */

    /**
     * Gets list entry "typepoint", with specified keys.
     */
    public Typepoint getTypepoint() throws JNCException {
        String path = "typepoint";
        return (Typepoint)searchOne(path);
    }

    /**
     * Iterator method for the list "typepoint".
     * @return An iterator for the list.
     */
    public ElementChildrenIterator typepointIterator() {
        return new ElementChildrenIterator(children, "typepoint");
    }

    /**
     * List method for the list "typepoint".
     * @return An List for the list.
     */
    public List<Typepoint> getTypepointList() {
        List<Typepoint> list = new ArrayList<>();
        ElementChildrenIterator iterator = typepointIterator();
        if(iterator==null){
            return null;
        }
        while (iterator.hasNext()){
            Typepoint next =(Typepoint) iterator.next();
            list.add(next);
        }
        return list;
    }

    /**
     * Adds list entry "typepoint", using an existing object.
     * @param typepoint The object to add.
     * @return The added child.
     */
    public Typepoint addTypepoint(Typepoint typepoint) throws JNCException {
        insertChild(typepoint, childrenNames());
        return typepoint;
    }

    /**
     * Adds list entry "typepoint".
     * This method is used for creating subtree filters.
     * @return The added child.
     */
    public Typepoint addTypepoint() throws JNCException {
        Typepoint typepoint = new Typepoint();
        insertChild(typepoint, childrenNames());
        return typepoint;
    }

    /**
     * Deletes list entry "typepoint", with specified keys.
     */
    public void deleteTypepoint() throws JNCException {
        String path = "typepoint";
        delete(path);
    }

    /* Access methods for list child: "notification-stream-replay". */

    /**
     * Gets list entry "notificationStreamReplay", with specified keys.
     */
    public NotificationStreamReplay getNotificationStreamReplay()
            throws JNCException {
        String path = "notification-stream-replay";
        return (NotificationStreamReplay)searchOne(path);
    }

    /**
     * Iterator method for the list "notification-stream-replay".
     * @return An iterator for the list.
     */
    public ElementChildrenIterator notificationStreamReplayIterator() {
        return new ElementChildrenIterator(children, "notification-stream-replay");
    }

    /**
     * List method for the list "notification-stream-replay".
     * @return An List for the list.
     */
    public List<NotificationStreamReplay> getNotificationStreamReplayList() {
        List<NotificationStreamReplay> list = new ArrayList<>();
        ElementChildrenIterator iterator = notificationStreamReplayIterator();
        if(iterator==null){
            return null;
        }
        while (iterator.hasNext()){
            NotificationStreamReplay next =(NotificationStreamReplay) iterator.next();
            list.add(next);
        }
        return list;
    }

    /**
     * Adds list entry "notificationStreamReplay", using an existing object.
     * @param notificationStreamReplay The object to add.
     * @return The added child.
     */
    public NotificationStreamReplay addNotificationStreamReplay(NotificationStreamReplay notificationStreamReplay)
            throws JNCException {
        insertChild(notificationStreamReplay, childrenNames());
        return notificationStreamReplay;
    }

    /**
     * Adds list entry "notificationStreamReplay".
     * This method is used for creating subtree filters.
     * @return The added child.
     */
    public NotificationStreamReplay addNotificationStreamReplay()
            throws JNCException {
        NotificationStreamReplay notificationStreamReplay = new NotificationStreamReplay();
        insertChild(notificationStreamReplay, childrenNames());
        return notificationStreamReplay;
    }

    /**
     * Deletes list entry "notificationStreamReplay", with specified keys.
     */
    public void deleteNotificationStreamReplay() throws JNCException {
        String path = "notification-stream-replay";
        delete(path);
    }

    /* Access methods for container child: "authentication-callback". */

    /**
     * Adds container entry "authenticationCallback", using an existing object.
     * @param authenticationCallback The object to add.
     * @return The added child.
     */
    public AuthenticationCallback addAuthenticationCallback(AuthenticationCallback authenticationCallback)
            throws JNCException {
        this.authenticationCallback = authenticationCallback;
        insertChild(authenticationCallback, childrenNames());
        return authenticationCallback;
    }

    /**
     * Adds container entry "authenticationCallback".
     * This method is used for creating subtree filters.
     * @return The added child.
     */
    public AuthenticationCallback addAuthenticationCallback()
            throws JNCException {
        AuthenticationCallback authenticationCallback = new AuthenticationCallback();
        this.authenticationCallback = authenticationCallback;
        insertChild(authenticationCallback, childrenNames());
        return authenticationCallback;
    }

    /**
     * Deletes container entry "authenticationCallback".
     * @return An array of the deleted element nodes.
     */
    public NodeSet deleteAuthenticationCallback() throws JNCException {
        this.authenticationCallback = null;
        String path = "authentication-callback";
        return delete(path);
    }

    /* Access methods for container child: "authorization-callbacks". */

    /**
     * Adds container entry "authorizationCallbacks", using an existing object.
     * @param authorizationCallbacks The object to add.
     * @return The added child.
     */
    public AuthorizationCallbacks addAuthorizationCallbacks(AuthorizationCallbacks authorizationCallbacks)
            throws JNCException {
        this.authorizationCallbacks = authorizationCallbacks;
        insertChild(authorizationCallbacks, childrenNames());
        return authorizationCallbacks;
    }

    /**
     * Adds container entry "authorizationCallbacks".
     * This method is used for creating subtree filters.
     * @return The added child.
     */
    public AuthorizationCallbacks addAuthorizationCallbacks()
            throws JNCException {
        AuthorizationCallbacks authorizationCallbacks = new AuthorizationCallbacks();
        this.authorizationCallbacks = authorizationCallbacks;
        insertChild(authorizationCallbacks, childrenNames());
        return authorizationCallbacks;
    }

    /**
     * Deletes container entry "authorizationCallbacks".
     * @return An array of the deleted element nodes.
     */
    public NodeSet deleteAuthorizationCallbacks() throws JNCException {
        this.authorizationCallbacks = null;
        String path = "authorization-callbacks";
        return delete(path);
    }

    /**
     * Support method for addChild.
     * Adds a child to this object.
     * 
     * @param child The child to add
     */
    public void addChild(Element child) {
        super.addChild(child);
        if (child instanceof AuthenticationCallback) authenticationCallback = (AuthenticationCallback)child;
        else if (child instanceof AuthorizationCallbacks) authorizationCallbacks = (AuthorizationCallbacks)child;
    }

}
